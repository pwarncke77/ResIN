ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_text(ggplot2::aes(x = node_frame$x, y = node_frame$y,
label = node_frame$node_names, color = node_frame[, plot_whichstat]), size = 3.8)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_distiller(palette = color_palette, direction = 1) +
ggplot2::scale_fill_distiller(palette = color_palette, direction = 1)+
ggplot2::labs(color = plot_whichstat, fill = plot_whichstat)+
theme(legend.text = ggplot2::element_text(size=10))
}
### Coloring by co-stats:
if(!(plot_whichstat %in% c("cluster", "choices", "Strength", "Betweenness", "Closeness", "ExpectedInfluence"))){
if(is.null(node_covars) | is.null(node_costats)) {
stop("You must select at least one node level covariate (node_covars) and specify at least one summary statistic (node_costats) to be able to visualize the latter.")
}
ResIN_ggplot <- remove_layer(ResIN_ggplot, c(2,3))
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot+
ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y, fill = node_frame[, plot_whichstat]),
shape = 21, size = 3)}else{
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_text(ggplot2::aes(x = node_frame$x, y = node_frame$y, label = node_frame$node_names,
color = node_frame[, plot_whichstat]), size = 3.8)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_distiller(palette = color_palette, direction = 1) +
ggplot2::scale_fill_distiller(palette = color_palette, direction = 1)+
ggplot2::labs(color = plot_whichstat, fill = plot_whichstat)+
theme(legend.text = ggplot2::element_text(size=10))
}
}
}
## Plotting ggplot graph:
if(plot_ggplot==TRUE) {
print(ResIN_ggplot)
}
## Final bit of housekeeping
node_frame$from <- NULL
edgelist_frame$x <- NULL
edgelist_frame$y <- NULL
edgelist_frame$node_names <- NULL
# Exporting features:
graph_stats <- list(structuration, centralization)
aux_objects <- list(res_in_cor, same_items, df_dummies, cluster_probs, max_cluster, ResIN_arglist)
names(aux_objects) <- c("adj_matrix", "same_items", "df_dummies", "cluster_probabilities", "max_clusterprob", "ResIN_arglist")
output <- list(edgelist_frame, node_frame, ResIN_ggplot, scores, graph_stats, aux_objects)
names(output) <- c("ResIN_edgelist", "ResIN_nodeframe", "ResIN_ggplot", "ResIN_scores", "graph_stats", "aux_objects")
class(output) <- c("list", "ResIN")
return(output)
}
ResIN_out <- ResIN(Core_Items, node_vars = c("legal_abort", "equalize_incomes", "keep_immigrants", "welfare_spending", "gay_marriage", "protect_environ", "gun_control", "aid_blacks"), node_covars = c("partisan"), node_costats = c("mean"), network_stats = TRUE, generate_ggplot = FALSE, plot_ggplot = FALSE, ResIN_scores = FALSE, seed = 151, detect_clusters = TRUE)
View(ResIN_out)
ResIN_boots_extract <- function(ResIN_boots_executed, what, summarize_results = FALSE) {
result <- list()
### Define search list function
search_list <- function(current_list, what) {
result <- list()
for (i in seq_along(current_list)) {
item <- current_list[[i]]
# Get the name if it exists; otherwise, set to NULL
name <- if (!is.null(names(current_list))) names(current_list)[i] else NULL
if (is.list(item)) {
# Recursively search the sublist and accumulate results
result <- c(result, search_list(item, what))
} else if (is.data.frame(item)) {
if (what %in% colnames(item)) {
result <- c(result, item[[what]])
}
} else if (!is.null(name) && name == what) {
result <- c(result, item)
}
}
return(result)
}
# Execute search list function
result <- search_list(ResIN_boots_executed, what = what)
### Optional summarize function
sum_res <- function(result) {
res_sum <- c(min(result, na.rm = TRUE),
quantile(result, 0.05, na.rm = TRUE),
quantile(result, 0.25, na.rm = TRUE),
median(result, na.rm = TRUE),
mean(result, na.rm = TRUE),
quantile(result, 0.75, na.rm = TRUE),
quantile(result, 0.95, na.rm = TRUE),
max(result, na.rm = TRUE),
sqrt(var(result, na.rm = TRUE)))
names(res_sum) <- c("min", "5th perct.", "25th perct.", "median", "mean",
"75th perct.", "95th perct.", "max", "stdn. dev.")
return(res_sum)
}
### Return the extracted quantities
if(summarize_results==FALSE) {
return(result)} else {
res_sum <-  sum_res(result)
return(res_sum)
}
}
ResIN_out <- ResIN(Core_Items, node_vars = c("legal_abort", "equalize_incomes", "keep_immigrants", "welfare_spending", "gay_marriage", "protect_environ", "gun_control", "aid_blacks"), node_covars = c("partisan"), node_costats = c("mean"), network_stats = FALSE, generate_ggplot = FALSE, plot_ggplot = FALSE, ResIN_scores = FALSE, detect_clusters = FALSE, seed = 151)
ResIN_prepped <- ResIN_boots_prepare(ResIN_out, n = 500, boots_type = "resample")
ResIN_prepped <- ResIN_boots_prepare(ResIN_out, n = 1000, boots_type = "resample")
ResIN_executed <- ResIN_boots_execute(ResIN_prepped, parallel = TRUE, n_cores = 20)
View(ResIN_executed)
ResIN <- function(df, node_vars = NULL, cor_method = "auto", weights = NULL,
method_wCorr = "Polychoric", poly_ncor = 2, neg_offset = 0,
ResIN_scores = TRUE, remove_negative = TRUE,
EBICglasso = FALSE, EBICglasso_arglist = NULL,
remove_nonsignificant = FALSE, sign_threshold = 0.05,
node_covars = NULL, node_costats = NULL,
network_stats = TRUE,
detect_clusters = FALSE, cluster_method = NULL, cluster_arglist = NULL,
cluster_assignment = TRUE,
seed = NULL, generate_ggplot = TRUE, plot_ggplot = TRUE,
plot_whichstat = NULL, plot_edgestat = NULL, color_palette = "RdBu", plot_responselabels = TRUE,
response_levels = NULL, plot_title = NULL, save_input = TRUE) {
if(save_input==TRUE){
ResIN_arglist <- list(df = df, node_vars = node_vars, cor_method = cor_method,
weights = weights, method_wCorr = method_wCorr, poly_ncor = poly_ncor, neg_offset = neg_offset,
ResIN_scores = ResIN_scores, remove_negative = remove_negative,
EBICglasso = EBICglasso, EBICglasso_arglist = EBICglasso_arglist,
remove_nonsignificant = remove_nonsignificant, sign_threshold = sign_threshold,
node_covars = node_covars, node_costats = node_costats,
network_stats = network_stats, detect_clusters = detect_clusters,
cluster_method = cluster_method, cluster_arglist = cluster_arglist,
cluster_assignment = cluster_assignment, seed = seed, generate_ggplot = generate_ggplot,
plot_ggplot = plot_ggplot, plot_whichstat = plot_whichstat, plot_edgestat = plot_edgestat,
color_palette = color_palette, plot_responselabels = plot_responselabels,
response_levels = response_levels, plot_title = plot_title, save_input = save_input)
} else {
ResIN_arglist <- "not stored"
}
if(!is.null(seed)){
set.seed(seed)
}
## Select response node_vars
if(is.null(node_vars)) {
df_nodes <- df
} else {
df_nodes <- dplyr::select(df, dplyr::all_of(node_vars))
}
## Make the dummy frame
df_nodes <- as.data.frame(apply(df_nodes, 2, factor))
df_nodes[df_nodes == "NA"] <- NA ## Re-setting NA's
df_dummies <- fastDummies::dummy_cols(df_nodes, ignore_na=TRUE,
remove_selected_columns=TRUE)
## Obtaining the choice level vector for plotting purposes
choices <- sapply(strsplit(colnames(df_dummies), "_"), function(parts) {
if (length(parts) > 2) {
paste(parts[-(1:2)], collapse = "_")
} else {""}})
if(! is.null(response_levels)) {
choices <- factor(choices, levels = response_levels)
}
## Generating correlation matrices
if(remove_nonsignificant==FALSE){
if(is.null(weights)) {
if(cor_method == "auto") {
res_in_cor <- qgraph::cor_auto(df_dummies, verbose = FALSE)
}
if(cor_method %in% c("pearson", "kendall", "spearman")) {
res_in_cor <- cor(df_dummies, method = cor_method, use = "pairwise.complete.obs")
}
### Weighted correlations:
} else {
res_in_cor <- matrix(NA, ncol(df_dummies), ncol(df_dummies))
for(i in 1:ncol(df_dummies))  {
for(j in 1:ncol(df_dummies))  {
temp <- as.data.frame(cbind(df_dummies[, i], df_dummies[, j], df[, weights]))
temp <- temp[complete.cases(temp), ]
res_in_cor[i, j]  <- wCorr::weightedCorr(temp[, 1], temp[, 2], weights=temp[, 3], method = method_wCorr)
}
}
colnames(res_in_cor) <- colnames(df_dummies)
rownames(res_in_cor) <- colnames(df_dummies)
}
## Perform regularization (optional)
if(EBICglasso==TRUE) {
diag(res_in_cor) <- 1
res_in_cor <- as.matrix(Matrix::nearPD(res_in_cor)$mat)
if(is.null(EBICglasso_arglist)) {
EBICglasso_arglist <- list(n = nrow(df), gamma = 0.5, penalize.diagonal = FALSE,
nlambda = 100,
returnAllResults = FALSE, checkPD = FALSE,
countDiagonal = FALSE, refit = FALSE,
threshold = FALSE, verbose = FALSE)
}
res_in_cor <- do.call(qgraph::EBICglasso, c(list(S = as.matrix(res_in_cor)),
EBICglasso_arglist))
}
}else{
## Remove non-significant edges
if(remove_nonsignificant==TRUE){
if(EBICglasso==TRUE){
stop("Removal of non-significant edges based on p-values cannot be combined with EBIC-glasso regularization.")
}
if(!(is.null(weights))){
stop("Removal of non-significant edges is not compatible with weighted correlation estimation.")
}
if(cor_method=="auto"){
cor_method <- "pearson"
}
if(cor_method %in% c("pearson", "kendall", "spearman")) {
res_corrtest <- psych::corr.test(df_dummies, method = cor_method, use = "pairwise.complete.obs", alpha = sign_threshold, adjust = "none")
res_corrtest$r[res_corrtest$p>sign_threshold] <- 0
res_in_cor <- res_corrtest$r
}
}
}
## Set all inner-variable correlations to 0
j <- 1 ; i <- 1
while(i <= ncol(df_nodes)) {
res_in_cor[j:((j+length(levels(factor(df_nodes[, i]))))-1),
j:((j+length(levels(factor(df_nodes[, i]))))-1)] <- 0
j <- j+length(levels(factor(df_nodes[, i]))); i <- i+1
}
## Removing NA's and negatives
if(remove_negative==TRUE) {
if(neg_offset>0 & neg_offset<1) {
res_in_cor[res_in_cor<0] <- res_in_cor[res_in_cor<0]+neg_offset
}
res_in_cor[res_in_cor<0] <- 0
}
res_in_cor[is.na(res_in_cor)] <- 0
## Creating the same-items list
same_items <- rep(NA, ncol(res_in_cor))
j <- 1 ; i <- 1
while(i <= ncol(df_nodes)) {
same_items[j:((j+length(levels(factor(df_nodes[, i]))))-1)] <- i
j <- j+length(levels(factor(df_nodes[, i]))); i <- i+1
}
same_items <- as.factor(same_items)
levels(same_items) <- colnames(df_nodes)
## Generating the qgraph and igraph objects
ResIN_igraph <- igraph::graph_from_adjacency_matrix(res_in_cor, mode = "undirected", weighted = TRUE, diag = FALSE)
ResIN_qgraph <- qgraph::qgraph(res_in_cor, DoNotPlot = TRUE, layout = "spring", labels = rownames(res_in_cor))
## Network statistics (common structuration and centralization metrics)
if(network_stats==TRUE) {
node_net_stats <- qgraph::centrality_auto(ResIN_qgraph, weighted = TRUE)
structuration <- apply(node_net_stats$node.centrality, 2, FUN = mean)
structuration[5] <- mean(node_net_stats$ShortestPathLengths)
structuration[6] <- DirectedClustering::ClustF(res_in_cor)$GlobalCC
names(structuration) <- c("average_betweenness", "average_closeness", "average_strength", "average_expected_influence", "average_path_length", "global_clustering")
centralization <- apply(node_net_stats$node.centrality, 2, FUN = sd)
names(centralization) <- c("betweenness_centralization", "closeness_centralization", "strength_centralization", "expected_influence_centralization")
} else {
structuration <- c("not estimated")
centralization <- c("not estimated")
}
## Generating and merging the basic plotting dataframe with network and covariate stats
if(remove_negative==FALSE) {
graph_layout <- as.data.frame(prcomp(igraph::layout_nicely(ResIN_igraph))$x)
} else {
graph_layout <- as.data.frame(prcomp(igraph::layout_with_fr(ResIN_igraph))$x)
}
graph_layout$node_names <- colnames(res_in_cor)
colnames(graph_layout) <- c("x", "y", "node_names")
node_frame <- graph_layout
node_frame$from <- node_frame$node_names
## Generating the edge-list data-frame
g <- igraph::as_data_frame(ResIN_igraph)
g$from.x <- node_frame$x[match(g$from, node_frame$node_names)]
g$from.y <- node_frame$y[match(g$from, node_frame$node_names)]
g$to.x <- node_frame$x[match(g$to, node_frame$node_names)]
g$to.y <- node_frame$y[match(g$to, node_frame$node_names)]
edgelist_frame <- dplyr::left_join(g, node_frame, by = "from")
### Adding edge-betweenness if desired
if(network_stats==TRUE) {
edgelist_frame$from_to <- paste(edgelist_frame$from, edgelist_frame$to, sep = "_")
node_net_stats$edge.betweenness.centrality$from_to <- paste(node_net_stats$edge.betweenness.centrality$from,
node_net_stats$edge.betweenness.centrality$to, sep = "_")
node_net_stats$edge.betweenness.centrality$from <- NULL
node_net_stats$edge.betweenness.centrality$to <- NULL
edgelist_frame <- left_join(edgelist_frame, node_net_stats$edge.betweenness.centrality, by = "from_to")
}
## Integrating node-level network stats only into node-frame
if(network_stats==TRUE) {
node_frame <- cbind(node_frame, node_net_stats$node.centrality)
}
## Perform clustering analysis
if(detect_clusters==TRUE) {
if(is.null(cluster_method)) {
cluster <- do.call(igraph::cluster_leading_eigen, c(list(graph = ResIN_igraph), cluster_arglist))
} else {
if(cluster_method=="cluster_leading_eigen") {
}
if(cluster_method=="cluster_fast_greedy") {
cluster <- do.call(igraph::cluster_fast_greedy, c(list(graph = ResIN_igraph), cluster_arglist))
}
if(cluster_method=="cluster_spinglass") {
cluster <- do.call(igraph::cluster_spinglass, c(list(graph = ResIN_igraph), cluster_arglist))
}
if(cluster_method=="cluster_edge_betweenness") {
cluster <- do.call(igraph::cluster_edge_betweenness, c(list(graph = ResIN_igraph), cluster_arglist))
}
if(cluster_method=="cluster_louvain") {
cluster <- do.call(igraph::cluster_louvain, c(list(graph = ResIN_igraph), cluster_arglist))
}
if(cluster_method=="cluster_leiden") {
cluster <- do.call(igraph::cluster_leiden, c(list(graph = ResIN_igraph), cluster_arglist))
}
if(cluster_method=="cluster_walktrap") {
cluster <- do.call(igraph::cluster_walktrap, c(list(graph = ResIN_igraph), cluster_arglist))
}
}
communities <- igraph::membership(cluster)
nodes <- names(communities)
outcome <- as.data.frame(cbind(as.numeric(communities), nodes))
colnames(outcome) <- c("cluster", "from")
outcome$cluster <- as.numeric(outcome$cluster)
x <- length(unique(outcome$cluster))
i <- 1
while(i <= x) {
if(length(outcome$cluster[outcome$cluster==i]) < 3) {
outcome$cluster[outcome$cluster==i] <- rep("NA", length(outcome$cluster[outcome$cluster==i]))
}
i <- i+1}
outcome$cluster[outcome$cluster=="NA"] <- NA
outcome$cluster <- as.numeric(outcome$cluster)
node_frame <- dplyr::left_join(node_frame, outcome, by = "from")
}
## Cluster assignment matrix and vectors
if(detect_clusters==TRUE & cluster_assignment==TRUE){
cluster_dummies <- as.matrix(df_dummies)
for(i in 1:ncol(cluster_dummies)) {
cluster_dummies[, i][cluster_dummies[, i]==1] <- node_frame$cluster[node_frame$node_names==node_frame$node_names[i]]
}
cluster_dummies[cluster_dummies==0] <- NA
cluster_probs <- as.data.frame(matrix(NA, nrow(df_dummies), max(node_frame$cluster, na.rm = TRUE)))
for(j in 1:max(node_frame$cluster, na.rm=TRUE)){
for(i in 1:nrow(df_dummies)){
cluster_probs[i, j] <- sum(cluster_dummies[i, ][cluster_dummies[i, ]==j]/j, na.rm = TRUE)/sum(!(is.na(cluster_dummies[i, ])))
}
}
colnames(cluster_probs) <- paste0("cluster_", names(table(node_frame$cluster)))
### Maximum probability assignment
temp_probs <- cluster_probs + rnorm(nrow(cluster_probs)*ncol(cluster_probs), 0, 0.001)
temp_probs <- dplyr::mutate(temp_probs, max_ind = max.col(temp_probs))
max_cluster <- temp_probs$max_ind
} else {
cluster_probs <- "not estimated"
max_cluster <- "not estimated"
}
## Calculating summary statistics based on co-variates
if(!(is.null(node_covars)) & !(is.null(node_costats))) {
if(length(node_covars) != length(node_covars)) {
stop("Covariate selection and summary statistics vectors must be of equal length.")
}
covars_frame <- as.matrix(dplyr::select(df, all_of(node_covars)))
cov_stats <- as.data.frame(matrix(NA, length(same_items), length(node_costats)))
for(i in 1:length(same_items)) {
for(j in 1:length(node_costats)) {
cov_stats[i, j] <- do.call(node_costats[j], c(list(x = covars_frame[, j][df_dummies[, i] == 1], na.rm = TRUE)))
}
}
colnames(cov_stats) <- paste(node_covars, node_costats, sep = "_")
cov_stats$node_label <- colnames(res_in_cor)
node_frame <- cbind(node_frame, cov_stats)
}
## Add choices to node_frame
node_frame$choices <- as.factor(choices)
## Scoring
if(ResIN_scores==TRUE & remove_negative==TRUE){
score_dummies_x <- as.matrix(df_dummies)
score_dummies_y <- as.matrix(df_dummies)
for(i in 1:ncol(score_dummies_x)){
score_dummies_x[, node_frame$node_names[i]][score_dummies_x[, node_frame$node_names[i]]==1] <- node_frame$x[node_frame$node_names==node_frame$node_names[i]]
score_dummies_y[, node_frame$node_names[i]][score_dummies_y[, node_frame$node_names[i]]==1] <- node_frame$y[node_frame$node_names==node_frame$node_names[i]]
}
score_dummies_x[score_dummies_x==0] <- NA
score_dummies_y[score_dummies_y==0] <- NA
scores_x <- apply(score_dummies_x, 1, FUN = function(x) {mean(x, na.rm=TRUE)})
scores_y <- apply(score_dummies_y, 1, FUN = function(x) {mean(x, na.rm=TRUE)})
scores <- as.data.frame(cbind(scores_x, scores_y))
} else {
scores <- "not estimated"
}
# ggplot visualization
if(generate_ggplot==FALSE){
ResIN_ggplot <- "not generated"
} else {
if(is.null(plot_title)){
plot_title <- paste("ResIN plot")
}
## generating base graph
ResIN_ggplot <- ggplot2::ggplot()+
ggplot2::coord_fixed(ratio=1, x = c(min(edgelist_frame$x-1.5), max(edgelist_frame$x+1.5)),
y = c(min(edgelist_frame$y-1.5), max(edgelist_frame$y+1.5)))
### Adding edge-weights if desired
if(is.null(plot_edgestat)){
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_curve(ggplot2::aes(x = edgelist_frame$from.x, xend = edgelist_frame$to.x, y = edgelist_frame$from.y, yend = edgelist_frame$to.y), curvature = 0.2, color = "black", alpha = 0.25)
}else{
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_curve(ggplot2::aes(x = edgelist_frame$from.x, xend = edgelist_frame$to.x, y = edgelist_frame$from.y, yend = edgelist_frame$to.y, linewidth = edgelist_frame[, plot_edgestat]), curvature = 0.2, color = "black", alpha = 0.25)+
ggplot2::scale_linewidth(range = c(0, 4))+
ggplot2::labs(linewidth = paste(plot_edgestat))
}
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y))
}else{
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_text(ggplot2::aes(x = node_frame$x, y = node_frame$y, label = node_frame$node_names), size = 3.8)
}
ResIN_ggplot <- ResIN_ggplot+
ggplot2::ggtitle(plot_title)+
ggplot2::theme_classic()+
ggplot2::theme(axis.line = element_blank(), axis.text.x = ggplot2::element_blank(), axis.title.x = ggplot2::element_blank(),
axis.text.y = ggplot2::element_blank(), axis.title.y = ggplot2::element_blank(),
axis.ticks = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(),
panel.grid.minor = ggplot2::element_blank(), legend.position = "bottom", legend.box = "vertical",
legend.text = ggplot2::element_blank(), plot.title = ggplot2::element_text(hjust = 0.5, size=15))
## function to remove layers
remove_layer <- function(ggplot_obj, layer_index) {
ggplot_obj$layers <- ggplot_obj$layers[-layer_index]
return(ggplot_obj)
}
## Different coloring options:
if(!is.null(plot_whichstat)){
### Color by clusters:
if(plot_whichstat=="cluster") {
if(detect_clusters==FALSE) {
stop("You must set detect_clusters to TRUE in order to visualize node clusters")
}
ResIN_ggplot <- remove_layer(ResIN_ggplot, c(2,3))
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot+
ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y, fill = as.factor(node_frame$cluster)),
shape = 21, size = 3)}else{
ResIN_ggplot <- ResIN_ggplot +
shadowtext::geom_shadowtext(ggplot2::aes(x = node_frame$x, y = node_frame$y, label = node_frame$node_names,
color = as.factor(node_frame$cluster)), size = 3.8, bg.r = 0.1)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_brewer(palette = color_palette) +
ggplot2::scale_fill_brewer(palette = color_palette) +
ggplot2::labs(color = "Cluster membership", fill = "Cluster membership")+
theme(legend.text = ggplot2::element_text(size=10))
}
if(plot_whichstat=="choices"){
ResIN_ggplot <- remove_layer(ResIN_ggplot, c(2,3))
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot+
ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y, fill = node_frame$choices),
shape = 21, size = 3)}else{
ResIN_ggplot <- ResIN_ggplot +
shadowtext::geom_shadowtext(ggplot2::aes(x = node_frame$x, y = node_frame$y, label = node_frame$node_names,
color = node_frame$choices), size = 3.8, bg.r = 0.1)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_brewer(palette = color_palette) +
ggplot2::scale_fill_brewer(palette = color_palette) +
ggplot2::labs(color = "Response choices", fill = "Response choices")+
theme(legend.text = ggplot2::element_text(size=10))
}
### Coloring by node-level centrality stats:
if(plot_whichstat %in% c("Strength", "Betweenness", "Closeness", "ExpectedInfluence")){
if(network_stats==FALSE) {
stop("You must set network_stats to TRUE in order to visualize a particular, node-level centrality metric.")
}
ResIN_ggplot <- remove_layer(ResIN_ggplot, c(2,3))
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot+
ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y, fill = node_frame[, plot_whichstat]),
shape = 21, size = 3)}else{
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_text(ggplot2::aes(x = node_frame$x, y = node_frame$y,
label = node_frame$node_names, color = node_frame[, plot_whichstat]), size = 3.8)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_distiller(palette = color_palette, direction = 1) +
ggplot2::scale_fill_distiller(palette = color_palette, direction = 1)+
ggplot2::labs(color = plot_whichstat, fill = plot_whichstat)+
theme(legend.text = ggplot2::element_text(size=10))
}
### Coloring by co-stats:
if(!(plot_whichstat %in% c("cluster", "choices", "Strength", "Betweenness", "Closeness", "ExpectedInfluence"))){
if(is.null(node_covars) | is.null(node_costats)) {
stop("You must select at least one node level covariate (node_covars) and specify at least one summary statistic (node_costats) to be able to visualize the latter.")
}
ResIN_ggplot <- remove_layer(ResIN_ggplot, c(2,3))
if(plot_responselabels==FALSE){
ResIN_ggplot <- ResIN_ggplot+
ggplot2::geom_point(ggplot2::aes(x = node_frame$x, y = node_frame$y, fill = node_frame[, plot_whichstat]),
shape = 21, size = 3)}else{
ResIN_ggplot <- ResIN_ggplot + ggplot2::geom_text(ggplot2::aes(x = node_frame$x, y = node_frame$y, label = node_frame$node_names,
color = node_frame[, plot_whichstat]), size = 3.8)
}
ResIN_ggplot <- ResIN_ggplot + ggplot2::scale_colour_distiller(palette = color_palette, direction = 1) +
ggplot2::scale_fill_distiller(palette = color_palette, direction = 1)+
ggplot2::labs(color = plot_whichstat, fill = plot_whichstat)+
theme(legend.text = ggplot2::element_text(size=10))
}
}
}
## Plotting ggplot graph:
if(plot_ggplot==TRUE) {
print(ResIN_ggplot)
}
## Final bit of housekeeping
node_frame$from <- NULL
edgelist_frame$x <- NULL
edgelist_frame$y <- NULL
edgelist_frame$node_names <- NULL
# Exporting features:
graph_stats <- list(structuration, centralization)
aux_objects <- list(res_in_cor, same_items, df_dummies, cluster_probs, max_cluster, ResIN_arglist)
names(aux_objects) <- c("adj_matrix", "same_items", "df_dummies", "cluster_probabilities", "max_clusterprob", "ResIN_arglist")
output <- list(edgelist_frame, node_frame, ResIN_ggplot, scores, graph_stats, aux_objects)
names(output) <- c("ResIN_edgelist", "ResIN_nodeframe", "ResIN_ggplot", "ResIN_scores", "graph_stats", "aux_objects")
class(output) <- c("list", "ResIN")
return(output)
}
ResIN_out <- ResIN(Core_Items, node_vars = c("legal_abort", "equalize_incomes", "keep_immigrants", "welfare_spending", "gay_marriage", "protect_environ", "gun_control", "aid_blacks"), node_covars = c("partisan"), node_costats = c("mean"), network_stats = FALSE, generate_ggplot = FALSE, plot_ggplot = FALSE, ResIN_scores = FALSE, detect_clusters = FALSE, seed = 151)
ResIN_prepped <- ResIN_boots_prepare(ResIN_out, n = 2, boots_type = "resample")
ResIN_executed <- ResIN_boots_execute(ResIN_prepped, parallel = TRUE, n_cores = 2)
ResIN_out <- ResIN(Core_Items, node_vars = c("legal_abort", "equalize_incomes", "keep_immigrants", "welfare_spending", "gay_marriage", "protect_environ", "gun_control", "aid_blacks"), node_covars = c("partisan"), node_costats = c("mean"), network_stats = FALSE, generate_ggplot = FALSE, plot_ggplot = FALSE, ResIN_scores = FALSE, detect_clusters = FALSE, seed = 151)
View(ResIN_out)
ResIN_out <- ResIN(Core_Items, node_vars = c("legal_abort", "equalize_incomes", "keep_immigrants", "welfare_spending", "gay_marriage", "protect_environ", "gun_control", "aid_blacks"), node_covars = c("partisan"), node_costats = c("mean"), network_stats = FALSE, generate_ggplot = FALSE, plot_ggplot = FALSE, ResIN_scores = FALSE, detect_clusters = FALSE, seed = 151)
remove.packages(ResIN)
remove.packages("ResIN")
devtools::check()
devtools::build()
roxygen2::roxygenize()
